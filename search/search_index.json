{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":""},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Documentation et analyse temporelle de m\u00e9thodes de tri</li> <li>Documentation du jeu tr\u00e9sor tropic</li> </ul>"},{"location":"compte_rendu_tri/","title":"Documentation de diff\u00e9rentes m\u00e9thodes de tri en python","text":""},{"location":"compte_rendu_tri/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>Documentation de diff\u00e9rentes m\u00e9thodes de tri en python<ul> <li>Table des mati\u00e8res</li> <li>Tri selection</li> <li>Tri insertion</li> <li>Tri rapide</li> <li>Tri fusion</li> </ul> </li> <li>Analyse temporelle de m\u00e9thodes de tri<ul> <li>Introduction</li> <li>M\u00e9thode</li> <li>Comparaison des r\u00e9sultats</li> <li>Comparaison avec la m\u00e9thode sort</li> <li>Conclusion</li> </ul> </li> </ul>"},{"location":"compte_rendu_tri/#tri-selection","title":"Tri selection","text":"<p>Le tri selection marche de la mani\u00e8re suivante:</p> <ul> <li>On cherche le minimum de la liste</li> <li>On l'\u00e9change avec le premier \u00e9l\u00e9ment</li> <li>On cherche le minimum de la liste restante</li> <li>On l'\u00e9change avec le deuxi\u00e8me \u00e9l\u00e9ment</li> <li>Et ainsi de suite</li> </ul> <p>Exemple d'impl\u00e9mentation:</p> <p><pre><code>def echanger(l, i, j):\n    \"\"\"\n    :param l: (list) une liste \n    :param i, j: (int) deux indices\n    :return: (NoneType) aucune\n    :Effet de bord: \u00e9change les \u00e9l\u00e9ments d'indice i et j de l.\n    :CU: 0 &lt;= i,j &lt; long(l)\n    :Exemples:\n\n    &gt;&gt;&gt; l1 =  [3, 1, 4, 9, 5, 1, 2]\n    &gt;&gt;&gt; l2 = l1.copy()\n    &gt;&gt;&gt; echanger(l2, 3, 5)\n    &gt;&gt;&gt; (l1[3], l1[5]) == (l2[5], l2[3])\n    True\n    \"\"\"\n    l[i], l[j] = l[j], l[i]\n\n\ndef select_min(l, a, b, comp=compare):\n    \"\"\"\n    :param l: (list) une liste\n    :param a, b: (int) deux indices\n    :param comp: (fonction) [optionnel] une fonction de comparaison\n                   Valeur par d\u00e9faut compare\n    :return: (int) l'indice du minimum dans la tranche l[a:b]\n    :CU: 0 &lt;= a &lt; b &lt;= long(l),\n         \u00e9l\u00e9ments de l comparables avec comp\n    :Exemples:\n\n    &gt;&gt;&gt; select_min([1, 2, 3, 4, 5, 6, 7, 0], 0, 8)\n    7\n    &gt;&gt;&gt; select_min([1, 2, 3, 4, 5, 6, 7, 0], 1, 7)\n    1\n    \"\"\"\n    ind_min = a\n    # l'indice du plus petit \u00e9l\u00e9ment de la tranche l[a:a+1] est ind_min\n    for i in range(a + 1, b):\n        # supposons que l'indice du plus petit \u00e9l\u00e9ment de la\n        # tranche l[a:i] est ind_min\n        if comp(l[i], l[ind_min]) &lt; 0:\n            ind_min = i\n        # alors l'indice du plus petit \u00e9l\u00e9ment de la tranche l[a:i+1]\n        # est ind_min\n    # \u00e0 l'issue de l'it\u00e9ration l'indice du plus petit \u00e9l\u00e9ment de la tranche\n    # l[a:b] est ind_min\n    return ind_min\n\n\ndef tri_select(l, comp=compare):\n    \"\"\"\n    :param l: (list) une liste \u00e0 trier\n    :param comp: (fonction) [optionnel] une fonction de comparaison\n                             Valeur par d\u00e9faut : compare\n    :return: (NoneType) aucune\n    :Effet de bord: modifie la liste l en triant ses \u00e9l\u00e9ments selon l'ordre d\u00e9fini par comp\n          Algorithme du tri par s\u00e9lection du minimum\n    :CU: l liste homog\u00e8ne d'\u00e9l\u00e9ments comparables selon comp\n    :Exemples:\n\n    &gt;&gt;&gt; l = [3, 1, 4, 1, 5, 9, 2]\n    &gt;&gt;&gt; tri_select(l)\n    &gt;&gt;&gt; l == [1, 1, 2, 3, 4, 5, 9]\n    True\n    &gt;&gt;&gt; from random import randrange\n    &gt;&gt;&gt; l1 = [randrange(1000) for k in range(randrange(100))]\n    &gt;&gt;&gt; l2 = l1.copy()\n    &gt;&gt;&gt; tri_select(l2)\n    &gt;&gt;&gt; est_trie(l2)\n    True\n    &gt;&gt;&gt; all(l1.count(elt) == l2.count(elt) for elt in l1)\n    True\n    &gt;&gt;&gt; all(l1.count(elt) == l2.count(elt) for elt in l2)\n    True\n    \"\"\"\n    n = len(l)\n    # la tranche l[0:1] est tri\u00e9e\n    for i in range(n - 1):\n        # supposons la tranche l[0:i+1] tri\u00e9e\n        ind_min = select_min(l, i, n, comp=comp)\n        echanger(l, i, ind_min)\n        # alors la tranche l[0:i+2] est tri\u00e9e\n    # \u00e0 l'issue de l'it\u00e9ration la tranche l[0:n] est tri\u00e9e\n</code></pre> exemple d'utilisation:</p> <pre><code>l = [3, 1, 4, 1, 5, 9, 2]\ntri_select(l)\nprint(l)\n\n&gt;&gt; Output: [1, 1, 2, 3, 4, 5, 9]\n</code></pre>"},{"location":"compte_rendu_tri/#tri-insertion","title":"Tri insertion","text":"<p>Le tri insertion consiste \u00e0 ins\u00e9rer chaque \u00e9l\u00e9ment de la liste \u00e0 sa place dans une liste d\u00e9j\u00e0 tri\u00e9e.</p> <pre><code>def inserer(l, i, comp=compare):\n    \"\"\"\n    :param l: (list) une liste\n    :param i: (int) indice de l'\u00e9l\u00e9ment de l \u00e0 ins\u00e9rer dans l[0:i+1]\n    :param comp: (fonction) [optionnel] une fonction de comparaison\n                             Valeur par d\u00e9faut : compare\n    :return: (NoneType) aucune\n    :Effet de bord: ins\u00e8re l'\u00e9l\u00e9ment l[i] \u00e0 sa place dans la tranche l[0:i+1]\n             de sorte que cette tranche soit tri\u00e9e si l[0:i] l'est auparavant\n    :CU: 0 &lt;= i &lt; long(l)\n         \u00e9l\u00e9ments de l comparables par comp\n         la tranche l[0:i] est tri\u00e9e\n    :Exemples:\n\n    &gt;&gt;&gt; l = [1, 2, 4, 5, 3, 7, 6]\n    &gt;&gt;&gt; inserer(l, 4)\n    &gt;&gt;&gt; l == [1, 2, 3, 4, 5, 7, 6]\n    True\n    &gt;&gt;&gt; inserer(l, 5)\n    &gt;&gt;&gt; l == [1, 2, 3, 4, 5, 7, 6]\n    True\n    &gt;&gt;&gt; inserer(l, 6)\n    &gt;&gt;&gt; l == [1, 2, 3, 4, 5, 6, 7]\n    True\n    \"\"\"\n    aux = l[i]\n    k = i\n    while k &gt;= 1 and comp(aux, l[k - 1]) &lt; 0:\n        l[k] = l[k - 1]\n        k = k - 1    \n    l[k] = aux\n\ndef tri_insert(l, comp=compare):\n    \"\"\"\n    :param l: (list) une liste \u00e0 trier\n    :param comp: (fonction) [optionnel] une fonction de comparaison\n    :return: (NoneType) aucune\n    :Effet de bord : modifie la liste l en triant ses \u00e9l\u00e9ments selon l'ordre d\u00e9fini par comp\n          Algorithme du tri par insertion\n    :CU: l liste homog\u00e8ne d'\u00e9l\u00e9ments comparables selon comp\n    :Exemples:\n\n    &gt;&gt;&gt; l = [3, 1, 4, 1, 5, 9, 2]\n    &gt;&gt;&gt; tri_insert(l)\n    &gt;&gt;&gt; l == [1, 1, 2, 3, 4, 5, 9]\n    True\n    &gt;&gt;&gt; from random import randrange\n    &gt;&gt;&gt; l1 = [randrange(1000) for k in range(randrange(100))]\n    &gt;&gt;&gt; l2 = l1.copy()\n    &gt;&gt;&gt; tri_insert(l2)\n    &gt;&gt;&gt; est_trie(l2)\n    True\n    &gt;&gt;&gt; all(l1.count(elt) == l2.count(elt) for elt in l1)\n    True\n    &gt;&gt;&gt; all(l1.count(elt) == l2.count(elt) for elt in l2)\n    True\n    \"\"\"\n    n = len(l)\n    # la tranche l[0:1] est tri\u00e9e\n    for i in range(1, n):\n        # supposons la tranche l[0:i] tri\u00e9e\n        inserer (l, i, comp=comp)\n        # alors la tranche l[0:i+1] est tri\u00e9e\n    # \u00e0 l'issue de l'it\u00e9ration la tranche l[0:n] est tri\u00e9e\n</code></pre> <p>exemple d'utilisation:</p> <pre><code>l = [3, 1, 4, 1, 5, 9, 2]\ntri_insert(l)\nprint(l)\n\n&gt;&gt; Output: [1, 1, 2, 3, 4, 5, 9]\n</code></pre>"},{"location":"compte_rendu_tri/#tri-rapide","title":"Tri rapide","text":"<p>Le tri rapide fonctionne de la mani\u00e8re suivante:</p> <ul> <li>On choisit un \u00e9l\u00e9ment de la liste</li> <li>On partitionne la liste en deux parties: les \u00e9l\u00e9ments plus petits que l'\u00e9l\u00e9ment choisi, et les \u00e9l\u00e9ments plus grands</li> <li>On trie r\u00e9cursivement les deux parties</li> </ul> <pre><code>def partitionner(l, debut, fin, comp=compare):\n    '''\n    :param l: (list) liste \u00e0 partitionner\n    :param debut, fin: (int) indices de d\u00e9but et de fin de la tranche de l\n                       \u00e0 partionner\n    :return: (int) indice o\u00f9 se trouve le pivot (initialement \u00e0 l'indice debut)\n                   apr\u00e8s le partionnement\n    :effet de bord: apr\u00e8s partionnement tous les \u00e9l\u00e9ments de la tranche l[debut:fin]\n                    ont \u00e9t\u00e9 d\u00e9plac\u00e9s de sorte que ceux situ\u00e9s \u00e0 gauche du pivot soient\n                    situ\u00e9s \u00e0 sa gauche, et les autres \u00e0 sa droite\n    :CU: 0 &lt;= debut &lt; fin &lt;= len(l)\n    :Exemples:\n\n    &gt;&gt;&gt; l = [3, 1, 4, 1, 5, 9, 2]\n    &gt;&gt;&gt; ind_pivot = partitionner(l, 2, 6)\n    &gt;&gt;&gt; ind_pivot\n    3\n    &gt;&gt;&gt; l\n    [3, 1, 1, 4, 5, 9, 2]\n    '''\n    pivot = l[debut]\n    ind_pivot = debut\n    for i in range (debut+1, fin):\n        if comp(pivot, l[i]) &gt; 0:\n            l[ind_pivot] = l[i]\n            l[i] = l[ind_pivot+1]\n            ind_pivot += 1\n    l[ind_pivot] = pivot\n    return ind_pivot\n\ndef tri_rapide(l, debut=0, fin=None, comp=compare):\n    \"\"\"\n    :param l: (list) une liste \u00e0 trier\n    :param comp: (fonction) [optionnel] une fonction de comparaison\n    :param debut, fin: (int) [optionnel] indices d\u00e9limitant la tranche \u00e0 trier\n    :return: (NoneType) aucune\n    :Effet de bord : modifie la liste l en triant \n          les \u00e9l\u00e9ments de la tranche l[debut:fin] selon l'ordre d\u00e9fini par comp\n          Algorithme du tri rapide\n    :CU: l liste homog\u00e8ne d'\u00e9l\u00e9ments comparables selon comp\n    :Exemples:\n\n    &gt;&gt;&gt; l = [3, 1, 4, 1, 5, 9, 2]\n    &gt;&gt;&gt; tri_rapide(l)\n    &gt;&gt;&gt; l == [1, 1, 2, 3, 4, 5, 9]\n    True\n    &gt;&gt;&gt; from random import randrange\n    &gt;&gt;&gt; l1 = [randrange(1000) for k in range(randrange(100))]\n    &gt;&gt;&gt; l2 = l1.copy()\n    &gt;&gt;&gt; tri_rapide(l2)\n    &gt;&gt;&gt; est_trie(l2)\n    True\n    &gt;&gt;&gt; all(l1.count(elt) == l2.count(elt) for elt in l1)\n    True\n    &gt;&gt;&gt; all(l1.count(elt) == l2.count(elt) for elt in l2)\n    True\n    \"\"\"\n    if fin is None: fin = len(l)\n    if fin - debut &gt; 1:\n        ind_pivot = partitionner(l, debut, fin, comp=comp)\n        tri_rapide(l, debut=debut, fin=ind_pivot, comp=comp)\n        tri_rapide(l, debut=ind_pivot+1, fin=fin, comp=comp)\n</code></pre> <p>exemple d'utilisation:</p> <pre><code>l = [3, 1, 4, 1, 5, 9, 2]\ntri_rapide(l)\nprint(l)\n\n&gt;&gt; Output: [1, 1, 2, 3, 4, 5, 9]\n</code></pre>"},{"location":"compte_rendu_tri/#tri-fusion","title":"Tri fusion","text":"<p>Le tri fusion fonctionne de la mani\u00e8re suivante:</p> <ul> <li>On divise la liste en deux parties</li> <li>On trie r\u00e9cursivement les deux parties</li> <li>On fusionne les deux parties tri\u00e9es</li> </ul> <pre><code>def separer(l):\n    \"\"\"\n    :param l: (list) liste \u00e0 s\u00e9parer en deux\n    :return: (tuple) couple de listes d'\u00e9gales longueurs (\u00e0 1 pr\u00e8s)\n    :CU: aucune\n    :Exemples:\n\n    &gt;&gt;&gt; l = [3, 1, 4, 1, 5, 9, 2]\n    &gt;&gt;&gt; l1, l2 = separer(l)\n    &gt;&gt;&gt; l3 = l1 + l2\n    &gt;&gt;&gt; len(l3) == len(l)\n    True\n    &gt;&gt;&gt; all(k in l for k in l3)\n    True\n    &gt;&gt;&gt; all(k in l3 for k in l)\n    True\n    \"\"\"\n    n = len(l)\n    if n == 0:\n        return ([], [])\n    elif n == 1:\n        return ([l[0]], [])\n    else:\n        l1, l2 = separer(l[2:])\n        return ([l[0]] + l1, [l[1]] + l2)\n    # autre possibilit\u00e9\n    # return (l[0:n//2], l[n//2:])\n\ndef fusionner(l1, l2, comp=compare):\n    \"\"\"\n    :param l1, l2: (list) deux listes (suppos\u00e9es tri\u00e9es)\n    :param comp: (optional) une fonction de comparaison\n    :return: (list) une liste contenant les \u00e9l\u00e9ments de l1 et l2\n              cette liste est tri\u00e9e si l1 et l2 le sont\n    :UC: les \u00e9l\u00e9ments de l1 et l2 doivent \u00eatre comparables selon comp\n    :Exemples:\n\n    &gt;&gt;&gt; fusionner([1, 3, 4, 9], [1, 2, 5])\n    [1, 1, 2, 3, 4, 5, 9]\n    \"\"\"\n    if l1 == []:\n        return l2.copy()\n    elif l2 == []:\n        return l1.copy()\n    else:\n        cmp = comp(l1[0], l2[0])\n        if cmp &lt;= 0:\n            return [l1[0]] + fusionner(l1[1:], l2, comp=comp)\n        else:\n            return [l2[0]] + fusionner(l1, l2[1:], comp=comp)\n\ndef tri_fusion(l, comp=compare):\n    \"\"\"\n    :param l: (list) une liste \u00e0 trier\n    :param comp: (fonction) [optionnel] une fonction de comparaison\n                             Valeur par d\u00e9faut : compare\n    :return: (list) \n    :Effet de bord: aucun\n          Algorithme du tri fusion\n    :CU: l liste homog\u00e8ne d'\u00e9l\u00e9ments comparables selon comp\n    :Exemples:\n\n    &gt;&gt;&gt; l = [3, 1, 4, 1, 5, 9, 2]\n    &gt;&gt;&gt; l2 = tri_fusion(l)\n    &gt;&gt;&gt; l2 == [1, 1, 2, 3, 4, 5, 9]\n    True\n    &gt;&gt;&gt; from random import randrange\n    &gt;&gt;&gt; l1 = [randrange(1000) for k in range(randrange(100))]\n    &gt;&gt;&gt; l2 = tri_fusion(l1)\n    &gt;&gt;&gt; est_trie(l2)\n    True\n    &gt;&gt;&gt; all(l1.count(elt) == l2.count(elt) for elt in l1)\n    True\n    &gt;&gt;&gt; all(l1.count(elt) == l2.count(elt) for elt in l2)\n    True    \"\"\"\n    n = len(l)\n    if n &lt;= 1:\n        return l.copy()\n    else:\n        l1, l2 = separer(l)\n        l1s = tri_fusion(l1, comp=comp)\n        l2s = tri_fusion(l2, comp=comp)\n        return fusionner(l1s, l2s, comp=comp)\n</code></pre> <p>exemple d'utilisation:</p> <pre><code>l = [3, 1, 4, 1, 5, 9, 2]\nl2 = tri_fusion(l)\nprint(l2)\n\n&gt;&gt; Output: [1, 1, 2, 3, 4, 5, 9]\n</code></pre> <p></p>"},{"location":"compte_rendu_tri/#analyse-temporelle-de-methodes-de-tri","title":"Analyse temporelle de m\u00e9thodes de tri","text":""},{"location":"compte_rendu_tri/#introduction","title":"Introduction","text":"<p>Ce document donne une comparaison des tris suivants:</p> <ul> <li>Tri s\u00e9l\u00e9ction</li> <li>Tri insertion</li> <li>Tri rapide</li> <li>Tri fusion</li> </ul>"},{"location":"compte_rendu_tri/#methode","title":"M\u00e9thode","text":"<p>Pour mesurer le temps d'ex\u00e9cution des algorithmes, nous utilisons la biblioth\u00e8que Python <code>timeit</code> afin d'ex\u00e9cuter plusieurs fois chaque fonction de tri avec des listes de tailles croissantes g\u00e9n\u00e9r\u00e9es al\u00e9atoirement. Chaque fonction est ex\u00e9cut\u00e9e 100 fois, et le temps moyen est calcul\u00e9 pour chaque taille de liste <code>n</code>.</p> <p>Les listes test\u00e9es sont de tailles croissantes allant de 1 \u00e0 500 \u00e9l\u00e9ments. Voici les algorithmes test\u00e9s :</p> <ul> <li> <p>Tri s\u00e9lection : Algorithme peu efficace pour les grandes listes. Il parcourt la liste pour trouver le plus petit \u00e9l\u00e9ment \u00e0 chaque it\u00e9ration.</p> </li> <li> <p>Tri insertion : L'algorithme ins\u00e8re chaque nouvel \u00e9l\u00e9ment \u00e0 sa place dans une liste d\u00e9j\u00e0 tri\u00e9e.</p> </li> <li> <p>Tri rapide : Un des algorithmes de tri les plus efficaces. Partitionne la liste et tri chaque sous-liste.</p> </li> <li> <p>Tri fusion : Division de la liste en sous-listes plus petites, puis fusion une fois tri\u00e9es.</p> </li> </ul>"},{"location":"compte_rendu_tri/#comparaison-des-resultats","title":"Comparaison des r\u00e9sultats","text":"<p> Figure 1 : Graphique comparant les temps d'ex\u00e9cution des diff\u00e9rents algorithmes de tri pour des listes de tailles croissantes. Pour 100 essais et n=10</p> <p> Figure 2 : Graphique comparant les temps d'ex\u00e9cution des diff\u00e9rents algorithmes de tri pour des listes de tailles croissantes. Pour 100 essais et n=100</p> <p> Figure 3 : Graphique comparant les temps d'ex\u00e9cution des diff\u00e9rents algorithmes de tri pour des listes de tailles croissantes. Pour 100 essais et n=500</p>"},{"location":"compte_rendu_tri/#comparaison-avec-la-methode-sort","title":"Comparaison avec la m\u00e9thode sort","text":"<p> Figure 4 : Graphique comparant les temps d'ex\u00e9cution des diff\u00e9rents algorithmes de tri pour des listes de tailles croissantes, avec la courbe de la m\u00e9thode sort incluse Pour 100 essais et n=500</p>"},{"location":"compte_rendu_tri/#conclusion","title":"Conclusion","text":"<p>Avec les r\u00e9sultats, nous pouvons voir que :</p> <ul> <li>Le tri sort est le plus performant, avec une valeur temporelle proche de 0 (Figure 4)</li> <li>Des 4 algo, le tri insertion semble \u00eatre plus efficace pour une petite liste (Figure 1)</li> <li>L'algorithme de tri rapide est plus efficace que les tris fusion, s\u00e9lection et insertion pour des listes de taille moyenne \u00e0 grande.</li> </ul>"},{"location":"tresor_tropic_doc/","title":"Documentation du Jeu \u201cTresor Tropic\u201d r\u00e9alis\u00e9 par Hugo Capon","text":""},{"location":"tresor_tropic_doc/#table-des-matieres","title":"Table des mati\u00e8res","text":"<ul> <li>Documentation du Jeu \u201cTresor Tropic\u201d r\u00e9alis\u00e9 par Hugo Capon<ul> <li>Table des mati\u00e8res</li> <li>0. Guide d'Installation et Lancement Rapide</li> <li>1. Introduction</li> <li>2. Objectif du Jeu</li> <li>3. R\u00e8gles<ul> <li>3.1 Mouvement</li> <li>3.2 Combat</li> </ul> </li> <li>4. Personnages<ul> <li>4.1 Joueurs</li> <li>4.2 Monstres</li> </ul> </li> <li>5. Plateau de Jeu</li> <li>6. \u00c9v\u00e9nements</li> <li>7. Gagner et Perdre</li> <li>8. Personnalisation</li> <li>9. D\u00e9veloppement et R\u00e9alisation</li> <li>10. Cr\u00e9dits</li> </ul> </li> </ul>"},{"location":"tresor_tropic_doc/#0-guide-dinstallation-et-lancement-rapide","title":"0. Guide d'Installation et Lancement Rapide","text":"<p>Commencez par t\u00e9l\u00e9charger le projet depuis le Git: http://extra.univ-littoral.fr/gitlab/capon.hugo/tresor-tropic.git</p> <p>Biblioth\u00e8ques n\u00e9cessaires:</p> <ul> <li>Python</li> <li>Pygame</li> </ul> <p>Lancement Rapide:</p> <ul> <li>Pour lancer le jeu graphique, allez dans le dossier \"Jeu\" et ex\u00e9cutez  \"MenuGraphique.py\"</li> <li>Pour lancer le jeu en Terminal, allez dans le dossier \"Jeu\" et ex\u00e9cutez  \"Main.py\"</li> </ul>"},{"location":"tresor_tropic_doc/#1-introduction","title":"1. Introduction","text":"<p>Bienvenue dans la documentation du jeu \u201cTresor Tropic\u201d. Ce jeu vous plonge dans un univers d\u2019aventure o\u00f9 des h\u00e9ros combattent des monstres redoutables pour atteindre le tr\u00e9sor. Pr\u00e9parez-vous \u00e0 vous combattre les uns les autres, car un seul jeu peut arriver au tr\u00e9sor !</p>"},{"location":"tresor_tropic_doc/#2-objectif-du-jeu","title":"2. Objectif du Jeu","text":"<p>L\u2019objectif de \u201cTresor Tropic\u201d est d\u2019arriver au tr\u00e9sor le premier. Mais cela ne sera pas aussi simple\u2026 Vous devrez combattre des monstres et joueurs adverses qui se dresseront sur votre chemin tout en atteignant la fin du plateau de jeu. Seuls les plus strat\u00e8ges et chanceux r\u00e9ussiront \u00e0 triompher !</p>"},{"location":"tresor_tropic_doc/#3-regles","title":"3. R\u00e8gles","text":""},{"location":"tresor_tropic_doc/#31-mouvement","title":"3.1 Mouvement","text":"<p>Pour avancer, lancez les d\u00e9s pour d\u00e9terminer combien de cases vous pouvez vous d\u00e9placer. Suivez les fl\u00e8ches du plateau pour progresser.</p>"},{"location":"tresor_tropic_doc/#32-combat","title":"3.2 Combat","text":"<p>Les combats se produisent lorsqu\u2019un joueur passe par une case monstre ou avance sur une case joueur. Lancez les d\u00e9s pour d\u00e9terminer le r\u00e9sultat du combat. Le plus haut score l\u2019emporte. En cas d\u2019\u00e9galit\u00e9, un nouveau combat commence.</p>"},{"location":"tresor_tropic_doc/#4-personnages","title":"4. Personnages","text":""},{"location":"tresor_tropic_doc/#41-joueurs","title":"4.1 Joueurs","text":"<p>Vous incarnez l\u2019un des quatre courageux h\u00e9ros. Chaque joueur a un avatar unique pour le repr\u00e9senter sur le plateau:</p> <ul> <li>Deux pirates,</li> <li>Un perroquet,</li> <li>Un aventurier,</li> <li>Un crocodile,</li> <li>Un pirate squelette.</li> </ul>"},{"location":"tresor_tropic_doc/#42-monstres","title":"4.2 Monstres","text":"<p>Vous affronterez une vari\u00e9t\u00e9 de monstres:</p> <ul> <li>Des cr\u00e9atures sauvages, </li> <li>Un monstre marin, </li> <li>Des pirates maudits.</li> </ul>"},{"location":"tresor_tropic_doc/#5-plateau-de-jeu","title":"5. Plateau de Jeu","text":"<p>Le plateau de jeu est compos\u00e9 30 cases. Les joueurs commencent case 1.</p>"},{"location":"tresor_tropic_doc/#6-evenements","title":"6. \u00c9v\u00e9nements","text":"<p>Des cases sp\u00e9ciales sont pr\u00e9sentes sur le plateau:</p> <ol> <li>Cases Echelles: Vous feront soit avancer soit reculer</li> <li>Cases Monstres</li> <li>Cases Joueurs (si joueur pr\u00e9sent)</li> <li>Cases sp\u00e9ciales: Permettent de une carte sp\u00e9ciale parmi 3 cartes: Rejouer, Echanger de position avec un joueur, ou bien Faire reculer un joueur</li> </ol>"},{"location":"tresor_tropic_doc/#7-gagner-et-perdre","title":"7. Gagner et Perdre","text":"<p>Pour gagner, atteignez la derni\u00e8re case du plateau. Vous perdez si un des joueurs est arriv\u00e9 avant vous.</p>"},{"location":"tresor_tropic_doc/#8-personnalisation","title":"8. Personnalisation","text":"<p>\u201cTresor Tropic\u201d offre des options de personnalisation d\u2019avatar et de choix de joueurs.  Quatre avatars sont s\u00e9lectionnables et vous pouvez jouer de 1 \u00e0 4 joueurs.</p>"},{"location":"tresor_tropic_doc/#9-developpement-et-realisation","title":"9. D\u00e9veloppement et R\u00e9alisation","text":"<p>Le jeu a \u00e9t\u00e9 d\u00e9velopp\u00e9 par Hugo Capon.  </p> <ol> <li>Langage et librairies:<ul> <li>Python</li> <li>Pygame</li> <li>json</li> <li>subprocess</li> </ul> </li> </ol>"},{"location":"tresor_tropic_doc/#10-credits","title":"10. Cr\u00e9dits","text":"<ol> <li>Personnages et map<ul> <li>Tiled pour la carte</li> <li>Water Assets pour Tiled</li> <li>Bing AI Image</li> <li>Game-icons.net</li> <li>Image by upklyak on Freepik</li> </ul> </li> <li>Vid\u00e9o</li> <li>Naughty Dog pour la musique d'Uncharted</li> </ol>"}]}